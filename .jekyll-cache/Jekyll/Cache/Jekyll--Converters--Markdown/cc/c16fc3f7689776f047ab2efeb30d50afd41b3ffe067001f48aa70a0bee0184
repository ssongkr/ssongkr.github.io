I"L<h2 id="들어가며">들어가며</h2>
<hr />
<p>클라이언트-서버 프로그래밍을 해봤다면 RESTful API를 듣고 사용해본 경험이 있을 것이다. 그렇다면 REST는 무엇일까? REST는 HTTP 프로토콜을 사용하는데 두 개념적 차이가 무엇일까?</p>

<p>REST가 무엇인지 설명하라고 하면 대답하기가 쉽지 않다. 이번 포스팅을 통해 초창기 웹의 모습을 살펴봄으로써, REST와 HTTP의 개념을 명확히 구분짓고자 한다.</p>

<p> </p>
<h2 id="wwwworld-wide-web의-등장">WWW(World Wide Web)의 등장</h2>
<hr />
<p>WWW(World Wide Web)은 1994년에 등장했다. 서로 연결된 컴퓨터들의 네트워크인 웹을 이용할 수 있다는 것은 큰 행운이다. 웹의 가장 큰 이점은 웹을 사용하는 유저들이 공유한 다양한 문서들을 쉽게 찾아볼 수 있다는 것이다.</p>

<p>웹의 아이디어는 혁신적이다. 웹 등장 이전에는 데이터를 저장하기 위해 닫힌 프레임을 이용했다. 하지만 웹의 등장으로 사용자는 다양한 자료를 저장하는 서버를 운영하여, 자신이 가진 자료를 다른 사용자에게 쉽게 공유할 수 있게 됐다.</p>

<p>웹은 여러 연구 기관을 비롯해 개인 사용자에게까지 퍼져나갔고, 웹 이용자는 누구나 쉽게 자신의 웹 사이트를 운영할 수 있게 됐다. 웹이 한계를 넘어 지속적으로 성장하고 있다는 것은 누구도 부정할 수 없는 사실이다.</p>

<p> </p>
<h2 id="rest-이전의-웹-상태">REST 이전의 웹 상태</h2>
<hr />
<p>웹의 초창기 구현은 매우 단순했다. 공유하고자 하는 정보를 호스팅하기 위해서 서버 소프트웨어를 실행하고, 컴퓨터를 웹에 연결하면 모든 작업이 끝났다. 작업이 마무리 되면 누구든지 장소에 상관없이 서버에 저장된 문서를 웹을 통해 요청할 수 있었다.</p>

<p>하지만 웹이 빠르게 성장하면서 문제가 발생했다. 인기있는 문서는 서로 다른 장소에 있는 이용자들로부터 많은 요청을 받게 되었다. 물리적으로 가까운 위치에 있는 사용자가 자료를 이미 받았더라도, 동일한 자료를 요청하는 사용자는 원래의 서버에 문서를 요청해야 했다.</p>

<p>그리고 사용자들은 다양한 방식으로 새로운 기술들을 사용하기 시작했다. 그들은 단순한 하이퍼텍스트 문서만 제공하는 대신 이미지를 웹 사이트에 추가했다. 초기 버전의 HTTP는 연결 당 하나의 문서만 제공할 수 있었기 때문에 이미지는 대체로 문서에 포함되어(inline) 있었다.</p>

<p> </p>
<h2 id="rest의-탄생">REST의 탄생</h2>
<hr />
<p>웹의 수요가 가파르게 증가하고 사용 방식이 다양해지면서 웹을 발전시키기 위한 많은 그룹이 생겼다. 그룹 중 하나는 <strong>HTTP Working Group</strong>으로, 이들은 성장하는 웹의 발전을 위해 새로운 요구사항들을 처리했다.</p>

<p>그리고 HTTP Working Group의 멤버 Roy Thomas Fielding은 REST(REpresentational State Transfer)라는 광범위한 아키텍처 개념을 동시에 연구했다.</p>

<p>REST 아키텍처와 HTTP 1.1 프로토콜은 서로 독립적이다. 하지만 HTTP 1.1 프로토콜은 REST의 원칙과 제약을 따르는 프로토콜로 개발되었다.</p>

<p>HTTP와 REST를 바라보는 한 가지 관점은 REST는 설계 방식이고, HTTP는 1.1은 REST의 원칙을 지킨 구현체라는 것이다. 실제로 HTTP와 REST는 동시에 설계되었다.</p>

<p> </p>
<h2 id="rest-to-the-rescue">REST to the rescue</h2>
<hr />
<p>그렇다면 가파르게 성장하면서 발생한 웹의 문제를 어떻게 해결했을까?</p>

<p>HTTP 1.1은 다음과 같이 요약할 수 있다.</p>
<ul>
  <li>클라이언트는 서버에 문서를 요청한다.</li>
  <li>서버는 무상태(Stateless)이며, 모든 상태는 클라이언트에 의해 처리된다.</li>
  <li>클라이언트는 요청을 나중에 사용하기 위해 요청을 캐시 할 수 있다.</li>
</ul>

<p>특히 클라이언트가 다운로드한 자산(Assets)을 캐시 할 수 있도록하는 것은 웹의 확장성을 위해 매우 중요한 개념이다. 아래의 예시를 살펴보자.</p>

<p>당신의 인디밴드가 1997년 여름에 히트 곡을 녹음했고, 갑자기 많은 사용자가 가난한(Pool) FTP 서버에서 동일한 파일을 다운로드한다고 가정해보자. 다운로더와 당신의 서버 사이에는 부하를 처리할 수 있는 하드웨어가 있다. (오직 당신의 허가(Permission)에 의해서만 캐싱을 할 수 있다.)</p>

<p>다행히 당신은 해야할 작업을 알고 있다. 당신은 최신 버전의 아파치 서버를 다운로드한다. 그리고 히트 곡의 링크를 가진 간단한 웹 페이지를 생성한다.</p>

<p>그 다음에 당신은 아파치 서버가 히트 곡 파일들을 HTTP 1.1 캐시 지시어 값이 <code class="highlighter-rouge">public</code>인 <code class="highlighter-rouge">Cache-Control</code> 헤더를 포함하여 전송하도록 설정한다. 이제 당신의 서버에 요청을 하지 않아도 중간 캐시 서버가 히트 곡 파일들을 제공할 수 있다. 따라서 파일을 제공하는데 필요한 네트워크의 트래픽을 줄일 수 있게 되었다.</p>

<p>REST의 원칙 중 하나는 서버의 응답을 캐시 할 수 있게 할 것인지에 대한 상태를 명시해야 한다는 것이다. HTTP 1.1은 Cache-Control 헤더를 이용해 구현한다.</p>

<p> </p>
<h2 id="마무리하며">마무리하며</h2>
<p>REST와 HTTP는 오늘날 우리가 알고 있는 거의 대부분의 인터넷을 구성하고 있다. 따라서 이 기술들을 당연한 것으로 받아들이기 쉽다. 그러나 이 기술들은 웹 전반에 걸쳐 중요한 역할을 해왔기 때문에 이 기술들이 왜 존재하는지에 대한 이유가 명확하다.</p>

<p>다음 블로그 포스트에서는 REST의 특성을 자세히 살펴보도록 하겠다.</p>

<p>https://restishistory.net/blog/do-you-know-the-difference-between-http-and-rest.html</p>
:ET