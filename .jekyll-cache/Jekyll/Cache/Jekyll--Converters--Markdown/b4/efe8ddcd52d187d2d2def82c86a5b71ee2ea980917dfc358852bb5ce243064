I"QW<h2 id="들어가며">들어가며</h2>
<hr />
<p>스프링 프레임워크를 공부하고 있는 학생이라면 IoC, DIP, DI, IoC-Container와 같은 단어를 많이 접해봤을 것이다. 이들을 우리말로 풀이하면 각각 제어의 역전, 의존관계 역전의 원칙, 의존성 주입, IoC 컨테이너이다. 이처럼 단어의 의미가 추상적이기 때문에 단순 해석만 봐서는 개념을 이해하기 어렵다. 이번 포스팅을 시작으로 위에서 언급한 개념들을 정리하고자 한다. 분량이 많기 때문에 이번 포스팅에서는 IoC에 대해서 알아보도록 하겠다.</p>

<p> </p>
<h2 id="디자인-원칙과-디자인-패턴">디자인 원칙과 디자인 패턴</h2>
<hr />
<p>앞서 언급한 개념들을 이해하기 위해서는 디자인 원칙(design principle)과 디자인 패턴(design pattern)의 차이를 이해해야한다. 각 용어가 무엇을 뜻하는지 살펴보자.</p>

<h4 id="디자인-원칙design-principle">디자인 원칙(Design Principle)</h4>
<ul>
  <li>높은 품질의 소프트웨어를 개발하기 위한 고수준(high-level)의 지침(guideline)이다.</li>
  <li>단순 지침이므로 구체적인 구현 방식을 명시하지 않는다. 따라서 프로그래밍 언어에도 종속되지 않는다.</li>
  <li>대표적인 예로 SOLID(SRP, OCP, LSP, ISP, DIP)가 있다.</li>
</ul>

<h4 id="설계-패턴design-pattern">설계 패턴(Design Pattern)</h4>
<ul>
  <li>객체 지향 프로그래밍에서 발생하는 문제를 해결하기 위한 저수준(low-level)의 구현 방식을 제안한다.</li>
  <li>대표적인 예로 싱글톤(singleton) 패턴이 있다.</li>
</ul>

<p>앞서 언급했던 IoC와 DIP는 디자인 원칙이고, DI는 디자인 패턴이다. 이에 유념하며 포스팅을 읽어보기 바란다.</p>

<p> </p>
<h2 id="제어의-역전ioc-inversion-of-controll">제어의 역전(IoC: Inversion of Controll)</h2>
<hr />
<p>IoC는 <strong>디자인 원칙</strong>이다. 이름에서 알 수 있는 것처럼 IoC는 프로그램 흐름, 종속 객체 생성 등 제어권을 변경하여(invert) 객체 지향 프로그래밍에서 느슨한 결합(loose coupling)을 가능하게 한다.</p>

<p><img src="/images/spring-ioc-1.png" alt="get-loosely-coupled-class" /></p>

<p>IoC를 쉽게 이해하기 위해 운전을 예로 들어보겠다. 만약 회사에 출근하기 위해 자동차를 운전한다면, 자동차의 제어권은 당신에게 있다. 그런데 당신이 운전기사를 고용한다면, 자동차의 제어권은 운전기사에게 넘어간다. 이것이 제어의 역전(IoC)이다.</p>

<p>그렇다면 IoC 원칙을 지키면 어떤 점이 좋은 것일까?</p>

<p>IoC는 클래스 간의 느슨한 결합(loose scoupling)을 가능하게 한다. 느슨한 결합은 클래스 간의 의존성을 줄여주기 때문에 프로그램을 더 쉽게 테스트 할 수 있게 하고, 유지보수하기 쉽게 해주며, 높은 확장성을 가지게 해준다.</p>

<p> </p>
<h3 id="프로그램-흐름-제어">프로그램 흐름 제어</h3>
<p>일반적으로 콘솔 어플리케이션은 메인 함수에서 실행된다. 따라서 메인 함수가 프로그램의 실행 흐름을 제어한다고 할 수 있다. 쉽게 말해 어플리케이션과 사용자가 상호작용 하는 일련의 순서를 결정한다.</p>

<p>아래의 자바 콘솔 앱을 예로 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Program</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">continueExecution</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">continueExecution</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Enter First Name: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">firstName</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Enget Last Name: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Do you want to save it? Y/N: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">wantToSave</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">wantToSave</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"Y"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">saveToDB</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span> <span class="n">lastName</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Do you want to Exit? Y/N: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">wantToExit</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">wantToExit</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"Y"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">continueExecution</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">saveToDB</span><span class="o">(</span><span class="nc">String</span> <span class="n">firstName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">lastName</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// save first name and last name to database here...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 <code class="highlighter-rouge">Program</code> 클래스의 <code class="highlighter-rouge">main()</code> 함수는 사용자의 이름, 데이터의 저장 여부, 프로그램의 종료 여부를 순서대로 입력받는다. 따라서 위 프로그램의 실행 흐름은 <code class="highlighter-rouge">main()</code> 함수에 의해 제어된다고 할 수 있다.</p>

<p>위의 콘솔 프로그램을 GUI 기반의 앱으로 만들면 IoC가 쉽게 구현된다. 윈도우 기반 앱 개발을 위한 프레임워크는 <code class="highlighter-rouge">이벤트</code> 사용하여 프로그램의 흐름을 제어하기 때문이다. 즉, 프로그램의 제어권이 <code class="highlighter-rouge">main()</code> 함수에서 <code class="highlighter-rouge">프레임워크</code>로 역전된 것이다.</p>

<p><img src="/images/spring-ioc-2.png" alt="window_application" /></p>

<p> </p>
<h3 id="의존-객체-생성-제어">의존 객체 생성 제어</h3>
<p>의존 객체를 생성 할 때도 IoC가 적용될 수 있다. 이를 설명하기에 앞서 의존성(Dependency)이 무엇인지 다음 예제 코드를 통해 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="no">B</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do something..</span>
        <span class="n">b</span><span class="o">.</span><span class="na">someMethod</span><span class="o">();</span>
        <span class="c1">// do something..</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">someMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do something..</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 A-클래스는 <code class="highlighter-rouge">task()</code> 메서드의 작업을 완료하기 위해서 <code class="highlighter-rouge">b.someMethod()</code>를 호출한다. 다시말해 A-클래스는 B-클래스의 도움 없이 <code class="highlighter-rouge">task()</code> 메서드의 작업을 완료할 수 없다. 이를 다른 말로 표현하면 <em>“A-클래스는 B-클래스에 의존적이다”</em> 혹은 <em>“B-클래스는 A-클래스의 의존성(Dependency)이다”</em>라고 할 수 있다.</p>

<p>객체 지향 디자인 접근 방식에서 클래스들은 기능을 완성하기 위해 서로 상호작용(interact) 해야한다. 위 예제에서 A-클래스는 B-클래스(dependency class)의 객체를 생성하고 생명주기를 관리한다.</p>

<p>IoC 원칙은 제어의 권한을 다른 클래스로 위임할 것을 제안한다. 제어의 역전 원칙은 제어의 권한을 다른 클래스로 위임하는 것이다. 다른 말로 의존성 객체의 생성 제어를 A-클래스에서 다른 클래스로 넘기는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>

    <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nc">Factory</span><span class="o">.</span><span class="na">getObjectOfB</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do something..</span>
        <span class="n">b</span><span class="o">.</span><span class="na">someMethod</span><span class="o">();</span>
        <span class="c1">// do something..</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="no">B</span> <span class="nf">getObjectOfB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 A-클래스는 B-클래스의 객체를 얻기 위해 Factory-클래스를 사용한다. 이는 종속 객체 생성의 제어를 A-클래스에서 Factory-클래스로 넘긴 것이다. 따라서 A-클래스는 B-클래스의 객체를 더 이상 생성하지 않고, Factory-클래스를 통해 B-클래스의 객체를 얻는다.</p>

<p>객체 지향 디자인에서는 클래스들이 느슨하게 결합(loosely coupled)되도록 설계 해야 한다. 클래스가 느슨하게 결합되어 있으면 한 클래스의 변화가 다른 클래스에 영향을 주지 않는다. 따라서 느슨한 결합은 앱의 유지 보수성을 높여준다.</p>

<p>느슨한 결합을 n-tier 아키텍처를 통해 조금 더 구체적으로 구체적으로 살펴보자.</p>

<p><img src="/images/spring-ioc-3.png" alt="n-tier-architecture" /></p>

<p>일반적으로 n-tier 아키텍처에서 UI는 데이터를 주고 받기 위해서 서비스 계층과 상호작용 한다. 서비스 계층은 <code class="highlighter-rouge">BusinessLogic</code> 클래스와 상호작용 하여 데이터에 대한 비즈니스 로직을 처리한다. <code class="highlighter-rouge">BusinessLogic</code> 클래스는 데이터를 받고 데이터베이스에 저장하는 <code class="highlighter-rouge">DataAccess</code> 클래스에 의존한다. 이것이 가장 단순한 n-tier 아키텍처이다.</p>

<p>IoC를 이해하기 위해 <code class="highlighter-rouge">BusinessLogic</code>과 <code class="highlighter-rouge">DataAccess</code> 클래스를 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomerBusinessLogic</span> <span class="o">{</span>
    
    <span class="nc">DataAccess</span> <span class="n">dataAccess</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CustomerBusinessLogic</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">dataAccess</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataAccess</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCustomerName</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">dataAccess</span><span class="o">.</span><span class="na">getCustomerName</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataAccess</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">DataAccess</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCustomerName</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Dummy customer Name"</span> <span class="c1">// get it from DB in real app;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 예제에서 살펴볼 수 있는 것처럼 CustomerBusinessLogic 클래스는 DataAccess 클래스에 의존한다. CustomerBusinessLogic 클래스는 Customer 데이터를 얻기 위해 DataAccess 클래스를 생성한다.</p>

<p>이제 위 예제에서 잘못된 점이 무엇인지 살펴보자.</p>

<p>위의 예제에서 CustomerBusinessLogic과 DataAccess는 강하게 연결된(tightly coupled) 클래스다. 그 이유는 CustomerBusinessLogic 클래스가 DataAccess 클래스의 참조(reference)를 포함하고 있기 때문이다. 그래서 DataAccess 클래스의 객체를 생성하고 생명주기(lifetime)를 관리한다.</p>

<p>위 예제 클래스의 문제점은 다음과 같다.</p>
<ol>
  <li>CustomerBusinessLogic과 DataAccess는 강하게 연결된 클래스다. 따라서 DataAccess 클래스의 변화는 CustomerBusinessLogic 클래스의 변화로 이어질 것이다. 예를들어, DataAccess 클래스의 메서드 이름을 변경하거나 메서드를 추가, 삭제하면 그에 알맞게 CustomerBusinessLogic 클래스의 내용을 수정해야한다.</li>
  <li>미래에 Customer 데이터를 다른 데이터베이스나 웹 서비스로부터 에서 가져와야 한다고 가정해보자. 그러면 다른 클래스를 새로 생성해야할 수도 있는데 이는 CustomerBusinessLogic 클래스의 변화로 이어질 것이다.</li>
  <li>CustomerBusinessLogic 클래스는 new 키워드를 사용하여 DataAccess 클래스를 생성한다. DataAccess 클래스의 객체를 생성하는 또 다른 다양한 클래스들이 있을 수 있을 것이다. 만약 DataAccess 클래스의 이름을 변경한다면, DataAccess 클래스의 객체를 생성한 모든 클래스를 찾아 클래스의 이름을 모두 변경해야 할 것이다. 이것은 동일한 클래스의 객체를 생성하기 위한 반복적인 코드이고 의존성을 가지도록 한다.</li>
  <li>CustomerBusinessLogic 클래스가 DataAccess 클래스의 객체를 생성하기 때문에 코드가 독립적으로 테스트 될 수 없다 (TDD). DataAccess 클래스는 목(mock) 클래스로 대체될 수 없다.</li>
</ol>

<p>위의 문제들을 해결하고 느슨하게 연결된 디자인(loosely coupled design)을 얻기 위해서 IoC와 DIP 원칙을 함께 사용할 수 있다. IoC는 패턴이 아니라 원칙(Principle)임을 기억하자. 원칙은 앞서 설명한 것 처럼 고 수준의 디자인 가이드라인이기 때문에 어떠한 구현 상세 정보도 주지 않는다. IoC 원칙을 구현하는 방식은 당신이 원하는데로 하면 된다.</p>

<p>느슨하게 결합 된 클래스를 얻는 첫 번째 단계로, Factory 패턴을 사용하여 IoC 원칙을 구현해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataAccessFactory</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">DataAccess</span> <span class="nf">getDataAccessObj</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DataAccess</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nf">CustomerBusinessLogic</span><span class="o">()</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">CustomerBusinessLogic</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCustomerName</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DataAccess</span> <span class="n">dataAccess</span> <span class="o">=</span> <span class="nc">DataAccessFactory</span><span class="o">.</span><span class="na">getDataAccessObj</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">dataAccess</span><span class="o">.</span><span class="na">getCustomerName</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예제에서 확인할 수 있는 것처럼 CustomerBusinessLogic 클래스는 DataAccessFactory.getCustomerDataAccessObj() 메서드를 이용하여 DataAccess 클래스를 얻는다. 이는 종속 클래스의 오브젝트 생성 제어를 CustomerBusinessLogic 클래서에서 DataAccessFactory 클래스로 반전시킨 것이다.</p>

<p>이것은 간단한 IoC 구현이고, 느슨하게 결합된 디자인을 얻기 위한 첫번째 단계다. 완전히 느슨하게 결합된 디자인을 얻기 위해서는 DIP, Stategy pattern, DI(Dependency Injection)을 사용해야한다.</p>

<p> </p>
<h2 id="마무리하며">마무리하며</h2>
<hr />
<p>IoC 원칙을 공부하기 전에는 DAO 클래스를 호출할 때 왜 Service 클래스를 이용하는지 명확히 이해하지 못했고, 단순 개인적인 추측을 할 뿐이었다. 이번 포스팅을 통해 이에 대한 명확한 해답을 얻게 된 것 같다.
다음 포스팅에서는 DI를 이용하여 어떻게 느슨한 결합 상태를 얻을 수 있는지 살펴보도록 하겠다.</p>

<p> </p>
<h2 id="참고">참고</h2>
<hr />
<ul>
  <li><a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">https://www.baeldung.com/</a>
https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring</li>
  <li><a href="https://www.tutorialsteacher.com/ioc/inversion-of-control">https://www.tutorialsteacher.com/</a></li>
</ul>
:ET