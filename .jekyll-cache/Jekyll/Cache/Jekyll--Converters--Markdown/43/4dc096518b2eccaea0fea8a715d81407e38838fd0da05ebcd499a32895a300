I"?V<h2 id="들어가며">들어가며</h2>
<hr />
<p>스프링 프레임워크를 공부하고 있는 학생이라면 IoC, DIP, DI, IoC-Container와 같은 단어를 많이 접해봤을 것이다. 이들을 우리말로 풀이하면 각각 제어의 역전, 의존관계 역전의 원칙, 의존성 주입, IoC 컨테이너이다. 이처럼 단어의 의미가 추상적이기 때문에 단순 해석만 봐서는 개념을 이해하기 어렵다. 이번 포스팅을 시작으로 위에서 언급한 개념들을 정리하고자 한다. 분량이 많기 때문에 이번 포스팅에서는 IoC에 대해서 알아보도록 하겠다.</p>

<p> </p>
<h2 id="디자인-원칙과-디자인-패턴">디자인 원칙과 디자인 패턴</h2>
<hr />
<p>앞서 언급한 개념들을 이해하기 위해서는 디자인 원칙(design principle)과 디자인 패턴(design pattern)의 차이를 이해해야한다. 각 용어가 무엇을 뜻하는지 살펴보자.</p>

<h4 id="디자인-원칙design-principle">디자인 원칙(Design Principle)</h4>
<ul>
  <li>높은 품질의 소프트웨어를 개발하기 위한 고수준(high-level)의 지침(guideline)이다.</li>
  <li>단순 지침이므로 구체적인 구현 방식을 명시하지 않는다. 따라서 프로그래밍 언어에도 종속되지 않는다.</li>
  <li>대표적인 예로 SOLID(SRP, OCP, LSP, ISP, DIP)가 있다.</li>
</ul>

<h4 id="설계-패턴design-pattern">설계 패턴(Design Pattern)</h4>
<ul>
  <li>객체 지향 프로그래밍에서 발생하는 문제를 해결하기 위한 저수준(low-level)의 구현 방식을 제안한다.</li>
  <li>대표적인 예로 싱글톤(singleton) 패턴이 있다.</li>
</ul>

<p>앞서 언급했던 IoC와 DIP는 디자인 원칙이고, DI는 디자인 패턴이다. 이에 유념하며 포스팅을 읽어보기 바란다.</p>

<p> </p>
<h2 id="제어의-역전ioc-inversion-of-controll">제어의 역전(IoC: Inversion of Controll)</h2>
<hr />
<p>IoC는 <strong>디자인 원칙</strong>이다. 이름에서 알 수 있는 것처럼 IoC는 프로그램 흐름, 종속 객체 생성 등 제어권을 변경하여(invert) 객체 지향 프로그래밍에서 느슨한 결합(loose coupling)을 가능하게 한다.</p>

<p><img src="/images/spring-ioc-1.png" alt="get-loosely-coupled-class" /></p>

<p>IoC를 쉽게 이해하기 위해 운전을 예로 들어보겠다. 만약 회사에 출근하기 위해 자동차를 운전한다면, 자동차의 제어권은 당신에게 있다. 그런데 당신이 운전기사를 고용한다면, 자동차의 제어권은 운전기사에게 넘어간다. 이것이 제어의 역전(IoC)이다.</p>

<p>그렇다면 IoC 원칙을 지키면 어떤 점이 좋은 것일까?</p>

<p>IoC는 클래스 간의 느슨한 결합(loose scoupling)을 가능하게 한다. 느슨한 결합은 클래스 간의 의존성을 줄여주기 때문에 프로그램을 더 쉽게 테스트 할 수 있게 하고, 유지보수하기 쉽게 해주며, 높은 확장성을 가지게 해준다.</p>

<p> </p>
<h3 id="프로그램-흐름-제어">프로그램 흐름 제어</h3>
<p>일반적으로 콘솔 어플리케이션은 메인 함수에서 실행된다. 따라서 메인 함수가 프로그램의 실행 흐름을 제어한다고 할 수 있다. 쉽게 말해 어플리케이션과 사용자가 상호작용 하는 일련의 순서를 결정한다.</p>

<p>아래의 자바 콘솔 앱을 예로 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Program</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">continueExecution</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">continueExecution</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Enter First Name: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">firstName</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Enget Last Name: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Do you want to save it? Y/N: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">wantToSave</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">wantToSave</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"Y"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">saveToDB</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span> <span class="n">lastName</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Do you want to Exit? Y/N: "</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">wantToExit</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">wantToExit</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"Y"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">continueExecution</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">saveToDB</span><span class="o">(</span><span class="nc">String</span> <span class="n">firstName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">lastName</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// save first name and last name to database here...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 <code class="highlighter-rouge">Program</code> 클래스의 <code class="highlighter-rouge">main()</code> 함수는 사용자의 이름, 데이터의 저장 여부, 프로그램의 종료 여부를 순서대로 입력받는다. 따라서 위 프로그램의 실행 흐름은 <code class="highlighter-rouge">main()</code> 함수에 의해 제어된다고 할 수 있다.</p>

<p>위의 콘솔 프로그램을 GUI 기반의 앱으로 만들면 IoC가 쉽게 구현된다. 윈도우 기반 앱 개발을 위한 프레임워크는 <code class="highlighter-rouge">이벤트</code> 사용하여 프로그램의 흐름을 제어하기 때문이다. 즉, 프로그램의 제어권이 <code class="highlighter-rouge">main()</code> 함수에서 <code class="highlighter-rouge">프레임워크</code>로 역전된 것이다.</p>

<p><img src="/images/spring-ioc-2.png" alt="window_application" /></p>

<p> </p>
<h3 id="의존-객체-생성-제어">의존 객체 생성 제어</h3>
<p>의존 객체를 생성 할 때도 IoC가 적용될 수 있다. 이를 설명하기에 앞서 의존성(Dependency)이 무엇인지 다음 예제 코드를 통해 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>

    <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="no">B</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do something..</span>
        <span class="n">b</span><span class="o">.</span><span class="na">someMethod</span><span class="o">();</span>
        <span class="c1">// do something..</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">someMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do something..</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 A-클래스는 <code class="highlighter-rouge">task()</code> 메서드의 작업을 완료하기 위해서 <code class="highlighter-rouge">b.someMethod()</code>를 호출한다. 다시말해 A-클래스는 B-클래스의 도움 없이 <code class="highlighter-rouge">task()</code> 메서드의 작업을 완료할 수 없다. 이를 다른 말로 표현하면 <em>“A-클래스는 B-클래스에 의존적이다”</em> 혹은 <em>“B-클래스는 A-클래스의 의존성(Dependency)이다”</em>라고 할 수 있다.</p>

<p>객체 지향 디자인 접근 방식에서 클래스들은 기능을 완성하기 위해 서로 상호작용(interact) 해야한다. 위 예제에서 A-클래스는 B-클래스(dependency class)의 객체를 생성하고 생명주기를 관리한다.</p>

<p>IoC 원칙은 제어의 권한을 다른 클래스로 위임할 것을 제안한다. 제어의 역전 원칙은 제어의 권한을 다른 클래스로 위임하는 것이다. 다른 말로 의존성 객체의 생성 제어를 A-클래스에서 다른 클래스로 넘기는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>

    <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nc">Factory</span><span class="o">.</span><span class="na">getObjectOfB</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// do something..</span>
        <span class="n">b</span><span class="o">.</span><span class="na">someMethod</span><span class="o">();</span>
        <span class="c1">// do something..</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="no">B</span> <span class="nf">getObjectOfB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 A-클래스는 B-클래스의 객체를 얻기 위해 Factory-클래스를 사용한다. 이는 의존 객체 생성의 제어를 A-클래스에서 Factory-클래스로 넘긴 것이다. 따라서 A-클래스는 B-클래스의 객체를 더 이상 생성하지 않고, Factory-클래스를 통해 B-클래스의 객체를 얻는다.</p>

<p>객체 지향 디자인에서는 클래스들이 느슨하게 결합(loosely coupled)되도록 설계 해야 한다. 클래스가 느슨하게 결합되어 있으면 한 클래스의 변화가 다른 클래스에 영향을 주지 않는다. 따라서 느슨한 결합은 앱의 유지 보수성을 높여준다.</p>

<p>느슨한 결합을 n-tier 아키텍처를 통해 조금 더 구체적으로 구체적으로 살펴보자.</p>

<p><img src="/images/spring-ioc-3.png" alt="n-tier-architecture" /></p>

<p>일반적으로 n-tier 아키텍처에서 UI는 데이터를 주고 받기 위해서 서비스 계층과 상호작용 한다. 서비스 계층은 <code class="highlighter-rouge">BusinessLogic</code> 클래스와 상호작용 하여 데이터에 대한 비즈니스 로직을 처리한다. <code class="highlighter-rouge">BusinessLogic</code> 클래스는 데이터를 받고 데이터베이스에 저장하는 <code class="highlighter-rouge">DataAccess</code> 클래스에 의존한다. 이것이 가장 단순한 n-tier 아키텍처이다.</p>

<p>IoC를 이해하기 위해 <code class="highlighter-rouge">BusinessLogic</code>과 <code class="highlighter-rouge">DataAccess</code> 클래스에 포커스를 맞춰보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomerBusinessLogic</span> <span class="o">{</span>
    
    <span class="nc">DataAccess</span> <span class="n">dataAccess</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CustomerBusinessLogic</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">dataAccess</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataAccess</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCustomerName</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">dataAccess</span><span class="o">.</span><span class="na">getCustomerName</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataAccess</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">DataAccess</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCustomerName</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Dummy customer Name"</span> <span class="c1">// get it from DB in real app;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예제에서 <code class="highlighter-rouge">CustomerBusinessLogic</code> 클래스는 <code class="highlighter-rouge">DataAccess</code> 클래스에 의존하여 데이터를 읽어온다. 그리고 데이터를 얻기 위해 <code class="highlighter-rouge">DataAccess</code> 클래스를 직접 생성한다.</p>

<p>위 예제의 문제점을 살펴보자.</p>

<p><code class="highlighter-rouge">CustomerBusinessLogic</code>와 <code class="highlighter-rouge">DataAccess</code>는 강하게 연결(tightly coupled)된 클래스다. 그 이유는 <code class="highlighter-rouge">CustomerBusinessLogic</code>은 <code class="highlighter-rouge">DataAccess</code>의 참조(reference)를 포함하기 때문에 <code class="highlighter-rouge">DataAccess</code>의 객체를 직접 생성하고 생명주기를 관리한다.</p>

<p>강한 연결로 발생할 수 있는 문제점은 다음과 같다.</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">DataAccess</code>의 변화가 <code class="highlighter-rouge">CustomerBusinessLogic</code>의 변화로 이어진다. <code class="highlighter-rouge">DataAccess</code>의 메서드 이름을 변경하거나 추가, 삭제하면 <code class="highlighter-rouge">CustomerBusinessLogic</code>의 내용도 함께 수정해야한다.</p>
  </li>
  <li>
    <p>추후에 데이터를 다른 데이터베이스나 웹 서비스를 통해 가져와야 한다면 데이터 접근을 위한 새로운 클래스를 만들어야 한다. 결과적으로 <code class="highlighter-rouge">CustomerBusinessLogic</code>의 내용도 함께 수정해야한다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">CustomerBusinessLogic</code>은 <em>new</em> 키워드를 사용하여 <code class="highlighter-rouge">DataAccess</code>의 객체를 생성한다. <code class="highlighter-rouge">DataAccess</code>의 객체를 생성하는 클래스가 많다면, <code class="highlighter-rouge">DataAccess</code>의 이름이 변경됐을때 <code class="highlighter-rouge">DataAccess</code>의 객체를 생성한 모든 클래스를 찾아 코드를 수정해야 할 것이다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">CustomerBusinessLogic</code>은 <code class="highlighter-rouge">DataAccess</code>의 객체를 생성한다. <code class="highlighter-rouge">DataAccess</code>를 Mock 클래스로 대체할 수 없기 때문에, 코드를 독립적으로 테스트 할 수 없다.</p>
  </li>
</ol>

<p>IoC와 DIP 원칙을 적용해 느슨하게 결합된 클래스를 구현하면 위 문제를 해결할 수 있다. Factory Pattern을 사용하여 IoC 원칙을 구현할 수 있다. 아래의 코드를 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataAccessFactory</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">DataAccess</span> <span class="nf">getDataAccessObj</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DataAccess</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nf">CustomerBusinessLogic</span><span class="o">()</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">CustomerBusinessLogic</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCustomerName</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DataAccess</span> <span class="n">dataAccess</span> <span class="o">=</span> <span class="nc">DataAccessFactory</span><span class="o">.</span><span class="na">getDataAccessObj</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">dataAccess</span><span class="o">.</span><span class="na">getCustomerName</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 <code class="highlighter-rouge">CustomerBusinessLogic</code>은 <code class="highlighter-rouge">DataAccessFactory</code>의 <code class="highlighter-rouge">getCustomerDataAccessObj()</code> 메서드를 사용하여 <code class="highlighter-rouge">DataAccess</code> 클래스를 얻는다. 이는 의존 클래스의 객체 생성 제어를 <code class="highlighter-rouge">CustomerBusinessLogic</code>에서 <code class="highlighter-rouge">DataAccessFactory</code>로 넘긴 것이다.</p>

<p> </p>
<h2 id="마무리하며">마무리하며</h2>
<hr />
<p>Factory Class는 IoC 구현의 간단한 구현(implementation)이다. 이는 느슨한 결합을 구현하기 위한 첫 번째 단계이다. 더욱 완전한 느슨한 결합 상태를 구현하려면 DIP, Stategy pattern, DI를 함께 사용해야한다.</p>

<p>다음 포스팅에서는 DIP 원칙을 적용하여 느슨한 결합을 한 단계 발전시켜보도록 하겠다.</p>

<p> </p>
<h2 id="참고">참고</h2>
<hr />
<ul>
  <li><a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">https://www.baeldung.com/</a></li>
  <li><a href="https://www.tutorialsteacher.com/ioc/inversion-of-control">https://www.tutorialsteacher.com/</a></li>
</ul>
:ET