---
title: "작성중인 포스팅입니다"
# title: "[Database] Index and B-Tree"
layout: post
# tags: ['ING']
# tags: ['DB', 'Index', 'B-Tree']
subtitle: ''
---


## 인덱스(색인)란?
---
데이터베이스의 인덱스를 살펴보기에 앞서 인덱스가 무엇인지 살펴보자. 위키백과에 정의된 인덱스의 정의는 다음과 같다.

> 색인(索引)은 책 속의 낱말이나 구절, 또 이에 관련한 지시자를 찾아보기 쉽도록 일정한 순서로 나열한 목록을 가리킨다. 인덱스(index)라고도 한다.

이처럼 색인은 핵심 키워드들을 사전 순서대로 정렬하여, 책의 내용을 한 눈에 볼 수 있도록 한다. 그리고 각 키워드는 책의 페이지와 매핑되어 우리가 찾고자 하는 내용을 빠르게 찾을 수 있도록 돕는다. 만약 책에 색인이 없다면 최악의 경우에는 우리가 원하는 내용을 찾기 위해 책의 모든 페이지를 넘겨봐야 할 것이다.


&nbsp;
## 데이터베이스 인덱스
---
데이터베이스의 인덱스도 이와 유사하다. 테이블에 데이터가 무분별하게 저장되어 있다면 특정 데이터를 조회하기 위해서 테이블의 모든 튜플을 검색해야 할 것이다. 그러나 데이터베이스의 인덱스를 이용하면 데이터를 조회하는 쿼리를 빠르게 수행할 수 있다.

인덱스는 특정 테이블과 관련이 있고, 한개 이상의 키로 구성된다. 키는 테이블의 컬럼을 기반으로 만들어지고, 키를 통해 인덱스를 조회하여 하나 이상의 데이터베이스 레코드를 찾을 수 있다.

이처럼 인덱스는 데이터를 조회하는 속도를 크게 향상시키므로, 각 테이블에 올바른 인덱스를 정의해야한다. 테이블의 크기가 작다면 크게 문제되지 않겠지만, 테이블의 크기가 크다면 인덱스의 정의 방식에 따라 테이블의 조회 시간이 크게 차이 날 것이다.

&nbsp;
## 카드 덱을 통해 인덱스 이해하기
---
인덱스의 개념을 더 쉽게 이해하기 위해 플레잉 카드를 예로 들어보자. 플레잉 카드의 구성 요소는 다음과 같다.

- 하트: 13장 (2, 3, 4, 5, 6, 7, 8, 9, J, Q, K, A)

- 스페이드: 13장 (2, 3, 4, 5, 6, 7, 8, 9, J, Q, K, A)

- 다이아몬드: 13장 (2, 3, 4, 5, 6, 7, 8, 9, J, Q, K, A)

- 클럽: 13장 (2, 3, 4, 5, 6, 7, 8, 9, J, Q, K, A)

덱은 위와 같이 총 52장의 카드로 구성되어 있다. 덱이 무작위로 섞여있는 상태에서 `스페이드-7`을 찾으려면 평균적으로 **26장**의 카드를 뒤집어서 확인해야한다.

![playing-card](/images/playing-card.webp)

이제 위 방식 대신, 카드를 모양별로 4개의 더미로 나누어 `스페이드-7`을 찾아야 하는 상황을 고려해보자. 먼저 4개의 더미에서 스페이드 모양을 찾으려면 평균적으로 2개의 카드 더미를 확인해야한다. 그리고 스페이드 카드 더미에서 `스페이드-7`을 찾으려면 평균적으로 7장의 카드를 뒤집어야 한다. 따라서 총 **9회**의 시간이 소요된다.

키(카드의 모양)를 이용하여 데이터를 분류하여 탐색 시간을 26회에서 9회로 크게 줄였다. 이것이 데이터베이스에서 인덱스를 사용하는 이유이다.


&nbsp;
## B+ 트리란?
---
**B+ 트리**는 데이터베이스 인덱스를 저장하는데 사용되는 자료구조다. B+ 트리는 앞서 설명한 카드 정렬 전략과 유사하게 동작한다. B+ 트리에서 **키 값(Key values)**은 여러 **노드**(카드 더미)에 분리되어 저장된다. 그리고 각 노드는 **트리 형태**로 연결된다. B+ 트리에서 노드에 저장된 키 값과 찾고자 하는 값을 비교하는 과정이 매우 빠르다. 쉽게 말해, 원하는 값을 찾기 위해 현재 노드에서 다음 노드로 분기하는 과정이 매우 빠르다. 각 노드는 탐색해야하는 데이터의 개수를 기하급수적으로 줄여준다.

이런 식으로, 노드를 따라 내려가면서 몇 번의 간단한 노드 스캔으로 수천 개의 레코드를 스캔하는 것을 피할 수 있다. 아래의 그림을 통해 아이디어를 설명하는데 도움이 되길 바라며...

> Image

위의 예제에서 키 값 `15`와 일치하는 데이터 레코드를 찾는다고 가정해보자. 값을 비교하는 과정은 다음과 같을 것이다.

1. `15`가 40보다 작기 때문에 `values < 40`로 분기한다.
2. `15`가 10보다 크고 30보다 작기 때문에, `values >= 10`와 `values < 16`으로 분기한다.

B+ 트리 구조를 사용하면 레코드의 개수에 비해 적은 분기를 통해 수천 개의 레코드가 표시 될 ㅅ ㅜ있다. 조회의 횟수는 트리의 높이와 직접적으로 관련이 있다. 따라서 모든 가지의 높이가 일정하게 유지되야 한다. 이렇게 하면 전체 트리에서 데이터가 분산되고, 모든 범위 내에서 데이터를 보다 효율적으로 조회 할 수 있다.

데이터베이스 내의 데이터는 지속적으로 업데이트 되므로 B+ 트리가 균형을 유지하는 것이 매우 중요하다. 레코드가 추가, 제거되가나 키가 업데이터 될 때마다 특수 알고리즘은 데이터와 키 값을 블록에서 블록으로 이동하여 트리의 한 부분이 다른 것보다 한 레벨 이상 높지 않도록 한다.


&nbsp;
마무리하며
---
실제 B+ 트리에서는 각 노드에는 수 많은 키 값이 포함된다. 그리고 각 노드는 디스크 블록의 크기이며 일반적으로 하드 드라이브에서 읽을 수 있는 가장 적은 양의 데이터다. 이처럼 B+ 트리는 매우 기술적이고 수학적인 요소이다. 세부 사항을 알고 싶다면 다음 포스팅을 읽어보는 것을 추천한다. 


&nbsp;
## 출처
---
- https://www.essentialsql.com/what-is-a-database-index/
- https://k39335.tistory.com/26
- https://ko.wikipedia.org/wiki/%EC%83%89%EC%9D%B8